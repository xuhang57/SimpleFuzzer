import java.io.File;
import java.util.Objects;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.LongStream;
import java.util.List;
import java.util.ArrayList;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;


public class Main {

    private static Method mainMethod = null;
    private static Object sourceObj = null;
    private static List<String> crashResult = new ArrayList<>();
    private static List<String> suspectedLoop = new ArrayList<>();
    private static Integer count = 0;
    /** Class variables to enable the GUI */
    private static GUI myGUI;
    private static boolean enableGUI;
    private static boolean enableLoops;

    /** For printResults to exit after first crash is found */
    private static long startTime;
    private static long totalNum;
    private static String sourceCodeName;
    private static double k;

    /**
     * Using Java Reflection to call Java Source Program
     * @param str the argument we used to feed the Java Source Program (SimpleBuggy)
     * @param m the main method in Java Source Program (SimpleBuggy)
     * @param obj the class object of Java Source Program (SimpleBuggy)
     */
    private static synchronized void callSource(String str, Method m, Object obj) {
        Object[] arg = new Object[1];
        arg[0] = new String[]{str};
        if(enableLoops) {
            Callable<Object> task = new Callable<Object>() {
                public Object call() {
                    try {
                        Object ob = m.invoke(obj, arg);
                        if (enableGUI) {
                            myGUI.tested_strings.append(str + '\n');
                        }
                        System.out.println("After invoking " + str + " no crash");
                        return ob;
                    } catch (InvocationTargetException ignore) {
                        // we don't need to maintain a list, we should exit the fuzzer whenever we have found one crash
                        crashResult.add(str + " Exception Type: " + ignore.getCause());
                        if (enableGUI) {
                            myGUI.crash_strings.append(str + '\n');
                        }
                        System.out.println("INVOKE EXCEPTION with " + str);
                        //find way to call printresults here
                        //printResults(startTime, totalNum, sourceCodeName, k);

                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    return obj;
                }
            };
            ExecutorService executor = Executors.newCachedThreadPool();
            Future<Object> future = executor.submit(task);
            try {
                Object res = future.get(5, TimeUnit.SECONDS);
            } catch (TimeoutException ex) {
                // handle the timeout
                suspectedLoop.add(str);
            } catch (InterruptedException e) {
                // handle the interrupts
            } catch (ExecutionException e) {
                // handle other exceptions
            } finally {
                future.cancel(true); // may or may not desire this
            }
            executor.shutdown();
        }
        //Loop detection not enabled
        else{
            try {
                m.invoke(obj, arg);
                System.out.println("After invoking " + str + " no crash");
            } catch(InvocationTargetException ignore) {
                // we don't need to maintain a list, we should exit the fuzzer whenever we have found one crash
                crashResult.add(str);
                System.out.println("INVOKE EXCEPTION with " + str);
                // System.exit(0);
            } catch(Exception e) {
                e.printStackTrace();
            }

        }
    }

    /**
     * Given a number (long), convert to a base 95 and form a string used as an argument
     * @param i the number generated by the LongStream.iterate()
     * @return A string that is used as an argument in callSource()
     */
    private static synchronized String convertTo(Long i) {
        count++;
        // Needs to be a StringBuffer so it would be a thread-safe variable
        StringBuffer sb = new StringBuffer();
        while (i != 0) {
            long offset = i % 95;
            Character c = (char) (offset + 32);
            sb.append(c);
            i /= 95;
        }
        return sb.toString();
    }

    /**
     * Using Scanner to parse user input from text file
     * @param file the file that we need to parse
     * @return A list of the parsed arguments
     */
    private static List<String> parseFile(File file) {
        //Set up array list for arguments, may have memory issues LOOK AT LATER!!!!
        List<String> arguments = new ArrayList<String>();
        Scanner input = null;

        //Try catch to make sure the file exists and can be accessed
        try{
            input = new Scanner(file);
        }
        catch (Exception e){
            System.out.println("Input file not accessible.");
            e.printStackTrace();
        }

        //Parse through file by newline and add to arguments
        if(input != null) {
            while (input.hasNext()) {
                arguments.add(input.nextLine());
            }

            //Close file stream
            input.close();
        }

        return arguments;

    }

    /**
     * Print the results of the fuzzer after a crash or after all inputs processed and exit
     * @param startTime the fuzzer's start time
     * @param totalNum total number of possible tests
     * @param sourceCodeName name of the source code that is being tested
     * @param k length of generated test strings
     */
    private static void printResults(long startTime, long totalNum, String sourceCodeName, double k){
        System.out.println("\nTotal running time: " + ((System.currentTimeMillis() - startTime) / 1000.0) + " seconds");
        System.out.println("Crash inputs: " + crashResult);
        if(enableLoops) {
            System.out.println("Infinite loops suspected with inputs: " + suspectedLoop);
        }
        System.out.println("Number of tested inputs: " + count);
        System.out.println("Number of all possible inputs: " + totalNum);
        System.out.println("Source code name: " + sourceCodeName);
        System.out.println("Length of tested arguments: " + k);

        //System.exit(0);
    }

    public static void main(String[] args) {

        // BEGIN INPUT PROCESSING
        enableGUI = false;
        enableLoops = false;
        File userInput;
        List<String> userArgs = null;
        File userSource = null;
        k = 1;

        // Number of arguments to the command line
        int num_args = args.length;

        // Check to see if we want to enable the GUI
        // FORMAT: ./fuzzer 1
        if(num_args == 1 && Integer.parseInt(args[0]) == 1){
            enableGUI = true;
        }

        // Initialize the GUI here to avoid null pointer exceptions
        myGUI = new GUI(enableGUI);

        if(enableGUI){

            // Wait until user hits run, make sure they input a file
            while(!myGUI.run_flag){

                // For some reason, if we don't include this print statement, nothing runs, so it's staying
                System.out.print("");

                // Check if the user wants to use their own input
                if(myGUI.user_input_flag){
                    userInput = myGUI.user_text_input;
                    // Parse input into args to feed the fuzzer
                    userArgs = parseFile(userInput);
                }
                // Check if the user wants to use their own source file
                if(myGUI.user_source_flag){
                    userSource = myGUI.java_source_code;
                }
            }

            // Get other values from GUI

            enableLoops = myGUI.enable_loops.isSelected();
            // If no length is selected, default is length 1, this avoids null pointer exceptions
            try {
                k = (int) myGUI.string_length.getSelectedValue();
            }
            catch (Exception e){
                k = 1;
            }
        }
        // GUI is not enabled, read arguments from command line
        else{
            // Checks for valid input
            if(num_args < 3){
                // Not enough args for base fuzzer implementation
                System.out.println("Invalid input format: please use the format:\n");
                System.out.println("\tfuzzer [source path] [source file name] [string length [1 to 5]] [enable loop detection (1 or 0)]");
                System.out.println("\tOR");
                System.out.println("\tfuzzer [enable GUI (1)]");
                System.exit(1);
            }
            else {
                // Get arguments if assumed valid
                k = Double.parseDouble(args[2]);

                if(k > 5 || k < 1){
                    System.out.println("Invalid input: please use a string length between 1 and 5");
                    System.exit(1);
                }
                if(num_args > 3){
                    if(Integer.parseInt(args[3]) == 1){
                        enableLoops = true;
                    }
                }
                // Other arguments for base fuzzer are obtained below or in the script
            }

        }

        // User arguments need to be final when feeding them to the fuzzer
        final List<String> userArgsFinal = userArgs;

        // totalNum changes depending on if the user provides their own input
        if(enableGUI && myGUI.user_input_flag){
            totalNum = (long) userArgs.size();
        }
        else {
            totalNum = (long) Math.pow(95, k);
        }

        // Get the name of the source code depending on if the user selected it or not, default is SimpleBuggy.java
        sourceCodeName = null;

        if(enableGUI && myGUI.user_source_flag){
            sourceCodeName = userSource.getName();
        }
        else if(enableGUI && !myGUI.user_source_flag){
            sourceCodeName = "SimpleBuggy.java";
        }
        else{
            // HARDCODED FOR TESTING, CHANGE LATER
            sourceCodeName = args[1];
        }

        // END INPUT PROCESSING CODE HERE

        // FUZZER RUN CODE HERE
        startTime = System.currentTimeMillis();

        // Get information from Java source program
        try {
            ClassLoader classLoader = Main.class.getClassLoader();
            // sourceCodeName -> SimpleBuggy.java -> SimpleBuggy
            Class aClass = classLoader.loadClass("source." + sourceCodeName.substring(0, sourceCodeName.length()-5));
            try {
                Constructor constructor = aClass.getConstructor();
                try {
                    Object obj = constructor.newInstance();
                    Method[] allMethods = aClass.getDeclaredMethods();
                    Method m = null;
                    // In OracleJDK, allMethods[0] seems always to be the main method. In OpenJDK, there is no order.
                    for (Method method : allMethods) {
                        if (method.getName().equals("main")) {
                            m = method;
                        }
                    }
                    if (m == null) {
                        System.out.println("Java Source Program doesn't contain a main function!");
                        throw new RuntimeException();
                    }
                    sourceObj = obj;
                    mainMethod = m;
                } catch (IllegalAccessException | InvocationTargetException | InstantiationException e) {
                    e.printStackTrace();
                }
            } catch(NoSuchMethodException e) {
                e.printStackTrace();
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }


        // Iterate from 0 to totalNum and convert it to the string argument that we can use to call with a Java source program
        try {
            LongStream printable = LongStream.iterate(0, i -> i + 1).limit(totalNum);
            printable
                    .parallel()
                    .forEach(i -> {
                        String s;
                        // Check if we want user arguments here
                        if(myGUI.user_input_flag){
                            s = userArgsFinal.get((int)i);
                        }
                        else{
                            s = convertTo(i);
                        }
                        // If just use m directly, it says the argument in lambda function needs to be final or effectively final
                        callSource(s, mainMethod, sourceObj);
                    });
        } catch(Exception e) {
            e.printStackTrace();
        }

        printResults(startTime, totalNum, sourceCodeName, k);
    }
}
